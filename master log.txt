This'll be used to log the different Mandelprograms here because there are tons
(if the spacing is off, it's Sublime Text's fault :c)



terms/planes:
SP1 				- c^2/(c^4 - 0.25) plane
newton's arctanz 	- Newton's fractal for f(z) = tanz - c



algorithms: (! means not yet finished, * means important/most used)
v1  	-> graph is centered at origin; no zooming possible; wonky shape outside set; 256 colours

v2  	-> zooming possible as graph is calculated relative to topleft coord and width; wonky shape outside set; 256 colours
v2.1 	-> ^ + smoother shape outside set, the generally used algorithm; still 256 out of 361 colours
v2.2 	-> ^ + 361 colours, finally

v3  	-> function-based; new colouring system where hue goes from 0 to 360, back to 0 and then modulus; saturation changes
v3.1  	-> ^ but hue cycles normally; saturation still changes
v3.2  	-> function-based but only hue is cycled like in v2.n, but now 256 colours; can invert hue
v3.3	-> ^ + switched back to using getrgb(); can now support upto 1530 colours instead of just 256; two times slower tho

*v4 	-> S M O O T H. Implementation of the fractional itern algorithm; shows progress; supports inverse Mandelbrot; timer
*v4.1 	-> (only for pygame) " + zooming feature; can move graph around with arrow keys

v5 		-> distance estimator formula to colour both the outside and the inside of the set; uses inverse of distance
*v5.1 	-> ^ but uses distance itself, close to the normally used mapping system online

v6		-> uses the outputs from all the three algorithms (v2,v4,v5.1) for the R, G, & B channels to make 6 permuted images
*v6.1 	-> (manually created with "3L to RGB.py", no dedicated program) ^ but v4, v5.1, and v9 used instead; looks cool!

v7		-> calculating distance travelled instead... or angle..?? im really not sure how this works, because it doesn't

*v8	 	-> Buddhabrot rendering technique! Doesn't support anti-Buddhabrot, however, and is my own implementation
v8.1 	-> new algorithm (taking random c's instead of taking all c's); support for anti-Buddhabrot; sorta worse though
*v8.2 	-> (false colour images created manually using "3L to RGB.py")

v9 		-> new cool looking colouring algorithm (taking last argument) for both inside and outside of the set
v9.1 	-> another method I invented to colour the inside of the set; two methods (division or multiplication with mod)

v10 	-> attempt at invention of new method of drawing lines between c's orbits; utter failure, covers entire screen
v10.1 	-> modified attempt that only draws lines from each c to ending z; still mostly a failure



discoveries:
- found out that, if the equation is z(n) = z(n-1)^k + c^m (where the number of bulbs on the Mandelbrot set would normally be k-1 if m=1, or m if k=2), the number of bulbs on the set is the product of what the number of bulbs would normally be if the other were normal (k=2 or m=1). Basically, no_of_bulbs = (k-1)*m! Verified this using v6 with 4 tests, one with even non-integer c:      (m,n:brots) = (3,2:4), (4,2:6), (4,3:9), (3,3.5:7)
- found a new kind of brot, one that I haven't seen anywhere: z = z^k + c, where k is negative. It's not fully rendered, because the escape radius is too high for the iter_limit, and it results in a much more interesting pattern than the one shown on wikipedia for negative powers of k! Made a gif with it too, it's v5.1NEG z^k



ideas still left to implement: (= means important, <> means done, < means no longer needed)
- using a separate preview set at fixed lower res and lower iterations to display progress of a render. After each horizontal line is rendered in the actual image, the corresponding line is quickly rendered AND drawn and updated on the display to indicate progress. This display might also have "Loading..." text with percentage completion? Once the full image is rendered, this display is killed and a new one with the actual image is loaded.
- rendering with PIL and displaying/interacting with pygame or some other module?
<> FOR ALL THE STUFFS (images AAAAND gifs): changing the constant in |z| > 2? prob even cycling THAT as a gif if it's interesting
<> make subsequent gifgens in PIL if it's faster
< julia_v2.1.py with v2.1 algorithm as well as zooming feature
= interactive mandelbrot that initialises z with coordinate clicked on initial set and generates new mandelbrot
- pygame_mandelbrot_v3 interactive
= ask how to improve speed of PIL/pygame mandelbrot; also ask best lang for generating mandelbrots and start tryna learn the display and class shit of that lang
- use timeit() on various shits in your mandelbrot program to see where the bottleneck is
<> speed up pygame by updating only the new vertical line (keep a vertical line Rect for this and translate it)
= an ACTUAL master log where I store the details of every image created as a new entry (date created, unique name, topleft coords, graph width and height)
- make a v3.1.py and compare the mandelbrots
- gif generator which instead *zooms* into a certain area of interest and takes gifs there. e.g. all these iteration gifs
<> roughly compare speeds of v3, v3.1, and v3.2 all in PIL as well as their mandelbrot quality
<> try distance estimation?
= of course, Mandelbrot in Java and other langs!
<> Buddhabrot
- v4 with custom colourmap/lookup table
= REMAKE ALL THE GIFS AND RENDERS IN V4 (JULIA SETS AND BURNING SHIP TOOOO)
= try using optimisations from online for the Mandelbrot
= Mandelbrot zooming gif that increases iterations according to your formula as it zooms in?
<> colour points inside the set in v5 according to disn estimator too?
<> USE DISTANCE ESTIMATOR EVERYWHERE!!!!!!!! AS WELL AS FRACTIONAL ITERATION
<> interactive Julia set graph that prerenders the screens at high iters but low reso (400x300 for e.g.), and only grabs the image it needs when mouse pointer is moved by hold-clicking. 1271 images if you use 0.1 steps...
- Julia set transformation gifs, e.g. cycling through the power (mightn't be that great tho)
== look at all the .py files in the main folder and put them in this log again
- v4 and v5 versions of each and every already rendered worthwhile gif
<> using all 3 techniques together (escape iters, fractional iters, disn estn) as 3 different channels for RGB??? permute imglist
= GATHER ALL GIFS IN GIF FOLDER, PREPARE FOR UPLOADING TO GITHUB
- gifs with SP1 plane
- the inverse mandelbrot set is really interesting; try translating different planes to invert the graph to infinity!
- parameterise the SP1 plane in a way that produces a normal c^1 (for a normal mandelbrot in the c plane) at a specific point for another gif?
<> z(n) = 1/z(n-1) + c?
- z(n) = (some weird function of z(n-1) divided by another weird function, prob parameterised) + c
- burning ship gifs too
<> NEG+INV?
= high reso buddha brot at the same spot as your facebook banner?
= inverse julia set. explorer/gif or anything like that? also julia sets for lotsa other equations, use a new mandeljulia for that
- ask why the distance estimator doesnt work inside of Julia sets
<> pygame program to draw the orbits of any point hovered over the mb set
= Buddabrot and anti-Buddhabrot but with all the other fractals too?
<> Buddhabrot but with drawing lines from each z to the next z?
= anti-anti buddhabrot using only points that *dont* escape?
<> permute Buddhabrot for 6 nebulabrots
= try rendering more jpgs for the pygame julia visualiser/collager to make a 0.05 step, but this time instead fill up the gaps left by the last render
- could try to allow irregular screen sizes in pygame, i.e. making the HEIGHT or graph_height independent of the WIDTH or graph_width, and allowing the screen size to change according to both topleft AND bottomright coords
= Mandelbrot (or any other fractal) zooming program that generates different images at different zooms, and fills in the gaps by resizing and cropping each image
<> colouring algorithm that colours hue according to the argument/phase of the last iterated z? Could combine this with distance estimator and fractional iteration for 3 colour bands, as there'll be variation in the set's colour itself!
- gif cycling shit with newton's method arctanz? and also try making your own formulae and seeing what fractals you get. e.g. z = z âˆ’ sin(z) * cos^m(z) + c^s * cos^t(z)
- julia sets of newton's arctanz?
- colour newton's method arctanz with distance estimator
- ask questions on fractalforums
- try improving v7 with logarithms?
= try using the Pickover stalk method?



NOTES:
- for gifs, it's ideal to use a 3/100 second delay (for ~30 fps); can use 2/100 delay instead for 50 fps
- PIL (with ImageDraw) is faster than pygame but non-interactive
- if you want to do a transition back and forth, e.g. black to red to black to red, 0 to 100 to 0 to 100, you can try increasing COLOURS to 200, inverting values that go over COLOURS/2 (100) by using COLOURS/2 - value, and voila. Or just use COLOURS*2
- use "pil_mandelbrot_v4 z^k gifgen.py" as a template for other gifgens?
- for the v4 algorithm (fractional iteration), the higher the ESCAPE_RADIUS is, the smoother (meaning more accurate) the gradient will be, so use a higher ESCAPE_RADIUS to avoid colour banding. HOWEVER, the greater the ESCAPE_RADIUS, the greater the iterations needed to escape will be, and this'll be especially evident when POWER < 1, causing the entire screen to be blank if iters isn't high enough.
- best settings for generating an inverse Mandelbrot: 800 x 450 px, graph_width = 8.5, topleft= -graph_width/2 + 2, graph_height/2
- in v4, you actually have to take the log of the log of the modulus to the base of the highest power of z in the equation. If the equation is z = (z^2 + c)^3, then the log must be taken to base 2*3=6!
- the set can be contained within -2 to 0.6 (0.8 for the antennae) and i to -i (1.2i for the antennae)



useful coords (topleftx, toplefty, width): (* - need to zoom out a bit or reposition topleft)
facebook banner: 					-0.10226371046153276,    0.9436655450744693, 5.5291747735886076e-08
facebook banner v2: 				-0.10226371046153276,    0.9436655460744693, 5.1291747735886074e-08
brot @ sorta low zoom: 					  -1.78672503125, 0.0006982968750000335,  0.0017579531250000446
asymmetric minibrot: 					  -0.76133815625,   0.08286390625000013,  0.0003609375000001025
*minibrot w/ colourful spikes: 		-0.14349632132377996, 	  1.018949937083907, 2.5790919955248626e-09
same brot ^ at greater zoom: 		 -0.1434963203533966, 	  1.018949936150034,  7.447128191895303e-10
same brot ^ 16:9 aspect ratio: 		-0.14349632039295948, 	  1.018949936037062,  7.447128191895303e-10 	(10000 iters)
very high zoom minibrot: 			-0.14349632016813998, 	 1.0189499359908307, 3.1720182036565348e-12 	(10000 iters)
newton's arctanz minibrot: 			  -1.317002406296134, 	 1.0723862635254862, 	0.17842097244858768



files log, ordered roughly by date created: (* means important/unique/most used) (some files may not be in the github repository)
mandelbrot.py 				- first working mandelbrot in Turtle; very slow, v1 algorithm
image_saver.py 				- program to convert .eps file from mandelbrot.py to a png
	(most stuff after this is pygame)
pygame_mandelbrot.py 		- first working mandelbrot in pygame; faster, still v1 algorithm

julia.py 					- first working julia set; v1 algorithm

julia_gif_gen.py 			- possibly first gif generator; cycles through real axis coords; v1 algorithm
mandelbrot_iterations_gif_gen.py - gif gen cycling through iterations; v1 algorithm

mandeljulia.py 				- program to first view the normal brot, and then generate julia on clicked point; v1 algorithm
mandeljulia_v2.py 			- same as ^ in most aspects; v1 algorithm

pygame_mandelbrot_v2.py		- first actually working mandelbrot w/ zoom; v2 algorithm
pygame_mandelbrot_vLog.py 	- failed attempt at implementation of log as from the advice from GLaD; v2 alg

pygame_mandelbrot_v2.1.py 	- first implementation of the normal algorithm to get rid of spikes; v2.1 algorithm

pygame_mandelbrot_v2HU.py 	- same as v2.py, but the hue value is shifted by a constant; v2 algorithm
pygame_mandelbrot_v2.1HU.py - same as ^; v2.1 algorithm

pygame_burning_ship_v1.py 	- first working burning ship; v2 algorithm 
pygame_burning_ship_v1.1.py - same as ^; v2.1 algorithm

pygame_mandelbrot_v2.1_fixedy.py - same as v2.1, but topleft_y is fixed to search for specific coords; v2.1 algorithm

*pygame_mandelbrot_v2versus2.1.py- program to highlight differences betn the v2 and v2.1 algs: only spikes were coloured

pygame_mandelbrot_v2.2.py 	- same as v2.1, but with 360 colour fix

pil_mandelbrot_v3.py 		- v3 algorithm in PIL
pil_mandelbrot_v3.1.py 		- ^ with normal hue changes
pil_mandelbrot_v3.2.py 		- improved version of v2 in PIL and function-based; normal colour representation
pil_mandelbrot_v3.3.py 		- switched back to slower getrgb dependency as preparation for v4

*pil_mandelbrot_v4.py 		- working v4 algorithm w/ loading percentage
pil_mandelbrot_v4REDDARK.py - ^ + algorithm that decreases value the closer the hue is to red; no loading percentage though
*pil_mandelbrot_v4INV.py 	- v4 but using the inverted Mandelbrot formula
pil_mandelbrot_v4BG.py 		- v4 but made specifically to generate background images; no zoom

pil_mandelbrot_v5.py 		- somehow working v5 algorithm; my own version of DE though, taking inverse of distance
*pil_mandelbrot_v5.1.py 	- improved algorithm that uses raw output from the DE alg; colours the set as well
pil_mandelbrot_v5.1BG.py 	- ^ but specifically for background images
*pil_mandelbrot_v5.1INV.py 	- v5.1 + support for inverse Mandelbrot set
*pil_mandelbrot_v5.1NEG.py 	- v5.1 + support for negative powers of z (both used to give ZeroDivisonErrors)

pil_mandelbrot_v6.py 		- functional program that combines outputs from 3 algs; kinda disappointing pictures though

*pil_julia_v4.py 			- upgraded Julia set w/ v4's  S M O O T H N E S S
pil_julia_v5.1.py 			- attempted v5.1 implementation of Julia set; works fine everywhere except in the set itself
pil_julia_v5.1D.py 			- full-on failure at trying to fix ^ using the decimal module

*pil_burningship_v5.1.py 	- working v5.1 implementation of the Burning Ship formula

pil_mandelbrot_v7.py 		- attempted implementation of an alg I found online; ugly images, could improve w/ log prob
pil_mandelbrot_v7DIS.py 	- another attempted implementation of a different version of the alg; still unappealing

*pil_mandelbrot_v8.py 		- somewhat working Buddhabrot program; my own implementation; still produces noisy images
pil_mandelbrot_v8.1.py 		- attempted but failed implementation of normal Buddhabrot algorithm; arguably worse images

*pygame_mandelbrot_v4.1.py 	- v4 in pygame, finally; zooming and moving around feature; optimisation to exclude cardioid
*pygame_mandelbrot_v5.1.py 	- v5.1 in pygame, too, with same extra features as ^; some zooms dont look that good though

pygame_newton'smethod_v4.1TANINVZ.py - implementation of a Newton's fractal in v4.1; formula source is stackexchange
*pygame_newton'smethod_v4.1NEWTONFRACTAL.py - generalisation to allow for customisable Newton's fractals
*pil_mandelbrot_v4NEWTONFRACTAL.py 			- ^ but in PIL, better for just rendering instead of displaying fractals

*pygame_mandelbrot_v9.py 	- new cool colouring alg I found that colours both outside and inside of set equally
*pygame_mandelbrot_v9.1.py 	- my own invented colouring alg (extension/generalisation of v4.1)

pygame_mandelbrot_v10.py 	- failure of a program; displays utter gibberish
pygame_mandelbrot_v10.1.py 	- semi-failure of a program (still displays something *sorta* cool in a special case)

master log.txt 				- this thing!


pygame julia set 2D explorer\
pil_julia_renderer_v4.py 	- program to pre-render a specified number of square Julia sets and store them
pygame_mandeljulia_viewer.py- a viewer that uses the pre-rendered images from ^ to display Julia sets in real time
pil_julia_collager.py 		- program to place all the pre-rendered images in a 2D image to form the Mandelbrot set


other programs\
hsv_range_pygame.py 		- v
hsv_range_v2.py 			- programs to generate a 2D HSV scale with V=100%

channel_splitter.py 		- simple program to split v6/v6.1 images into their respective channels for debugging
L to RGB, R.py 				- program to convert grayscale image to RGB, with only the R channel being occupied
L to HSV, H.py 				- ^ but grayscale to HSV, with only the H channel being occupied, the other two being constant
3L to RGB, permute.py 		- program to permute 3 grayscale images into 6 differently coloured RGB images; for v6.1 AND v8

black_remover.py 			- program to replace the colour of the set in a Mandelbrot image with any other colour
hue_changer.py 				- program to change hues of all pixels outside of the set; used w/ ^ to post-customise colours